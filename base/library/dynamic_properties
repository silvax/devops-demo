#!/usr/bin/python

DOCUMENTATION = '''
---
module: dynamic_properties
short_description: Manages dynamic properties in DynamoDB.
description:
    - Manages dynamic properties in DynamoDB. The module basically has
    - 3 functions which can be executed separately or together. It will
    - read from a local data source, synchronize the local template with
    - DynamoDB, and/or read data from existing/created DynamoDB tables.
    - Operation is controlled by which options are provided and the format of
    - the local data file, if provided.
    - This module assumes the format of local and DynamoDB data is
    - consistent with the one described here:
    - https://confluence.inin.com/display/PureCloud/Dynamic+Properties
    - All data is returned as Ansible facts. The fact names are the provided
    - prefix followed by the table key name. Key names have all ':', '-', and '.'
    - characters converted to '_' to conform to Ansible variable naming rules.
author: Ben Newlin <ben.newlin@inin.com>
requirements:
    - boto
options:
    prefix:
        description:
            - String prefix to use for facts generated by this module. Must
            - be unique for each playbook run.
        required: true
        default: []
    file:
        description:
            - A JSON file on the remote host which the module will use as a
            - data source. If the file contains a 'sourceName' element, the local
            - data definition will be synchronized with the DynamoDB table of that
            - name, including creation of the table if it does not exist.
            - If C(file) is specified, the value of C(table) is ignored.
            - At least one of C(file) or C(table) must be provided.
        required: false
        default: []
    table:
        description:
            - A DynamoDB table to be used as the data source.
            - If C(file) is specified, the value of C(table) is ignored.
            - At least one of C(file) or C(table) must be provided.
        required: false
        default: []
    key:
        description:
            - Name of the HashKey of the table.
        required: false
        default: 'key'
    timeout:
        description:
            - Number of seconds to wait for a newly created DynamoDB table to
            - become active before assuming failure.
        required: false
        default: 60
'''

import json
import os.path
import datetime
import time

try:
    import boto
    from boto.dynamodb2.table import Table
    from boto.dynamodb2.fields import HashKey
except:
    IMPORT_ERROR=True
else:
    IMPORT_ERROR=False

class DynamicProperties(object):

    def __init__(self, module):
        self.module  = module
        self.file = module.params['file']
        self.table = module.params['table']
        self.key = module.params['key']
        self.prefix = module.params['prefix']
        self.timeout = module.params['timeout']

    def run(self):
        changed = False
        schema = None
        table = None
        data = {}
        result_set = {}

        if not self.file and not self.table:
            self.module.fail_json(msg="At least one of file or table must be provided.")
            return

        if self.file:

            if not os.path.isfile(self.file):
                self.module.fail_json(msg="Local file does not exist. (" + self.file + ")")
                return

            with open(self.file) as schema_file:
                schema = json.load(schema_file)

            if 'serviceProperties' not in schema:
                self.module.fail_json(msg="Local table definition contains no 'serviceProperties' element.")
                return

            if 'properties' in schema['serviceProperties']:
                result_set = schema['serviceProperties']['properties']

            if 'sourceName' in schema['serviceProperties']:
                self.table = schema['serviceProperties']['sourceName']
            else:
                self.table = None

        if self.table:
            try:
                conn = boto.connect_dynamodb()
            except:
                self.module.fail_json(msg="Failed to connect to DynamoDB. Credentials may be expired.")
                return

            try:
                conn.describe_table(self.table)
            except:
                if not schema:
                    self.module.fail_json(msg="Specified DynamoDB table does not exist.")
                    return

                table = Table.create(self.table, schema=[HashKey(self.key)])
                ready = False
                time_left = self.timeout
                while not ready and (time_left > 0):
                    time.sleep(1)
                    time_left -= 1
                    desc = conn.describe_table(self.table)
                    if desc['Table']['TableStatus'] == 'ACTIVE':
                        ready = True

                if not ready:
                    self.module.fail_json(msg="Timeout waiting for DynamoDB table to become active. (%d secs)" % self.timeout)
                    return

                changed = True
            else:
                table = Table(self.table)

            if table:
                if schema:
                    with table.batch_write() as batch:
                        for item in result_set:
                            try:
                                db_item = table.get_item(**{self.key: item[self.key]})
                            except:
                                item['dateModified'] = datetime.datetime.now().strftime("%a %b %d %H:%M:%S %Z %Y")
                                batch.put_item(data=item)
                                changed=True
                            else:
                                if ('defaultValue' not in db_item) or (db_item['defaultValue'] != item['defaultValue']):
                                    db_item['defaultValue'] = item['defaultValue']
                                    changed=True
                                if ('description' not in db_item) or (db_item['description'] != item['description']):
                                    db_item['description'] = item['description']
                                    changed=True
                                if changed:
                                    db_item['dateModified'] = datetime.datetime.now().strftime("%a %b %d %H:%M:%S %Z %Y")
                                    batch.put_item(data=db_item)

                result_set = table.scan()

        for item in result_set:
            key = self.prefix + "_" + item[self.key].replace(':','_').replace('-','_').replace('.','_')
            if 'value' in item:
                data[key] = str(item['value'])
            elif 'defaultValue' in item:
                data[key] = str(item['defaultValue'])

        return data

def main():

    module = AnsibleModule(
        argument_spec = dict(
            prefix    = dict(required=True, type='str'),
            file      = dict(required=False, default=None, type='str'),
            table     = dict(required=False, default=None, type='str'),
            key       = dict(required=False, default='key', type='str'),
            timeout   = dict(required=False, default=30, type='int')
        )
    )

    if IMPORT_ERROR:
        module.fail_json(msg="Required libraries not present! (boto)")
        return

    properties = DynamicProperties(module).run()
    facts = dict(changed=False, ansible_facts=properties)

    module.exit_json(**facts)

# import module snippets
from ansible.module_utils.basic import *
from ansible.module_utils.urls import *

main()
